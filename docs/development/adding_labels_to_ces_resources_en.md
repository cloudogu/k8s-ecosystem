# Labels to Cloudogu EcoSystem resources

This policy aims to provide an overview when and when not to _programmatically apply labels_ to CES components during the course of developing components that create CES Kubernetes resources. Additionally, this policy helps to give an overview which labels should be used. Of course everyone is encouraged to set custom labels for their liking because Kubernetes labels are a generic way of adding semantics visible to users.

---

Labels are a Kubernetes-native key-value pairs that are attached to Kubernetes objects, f. i. deployments, pods, and so on. They only carry a meaning to users. Labels help users to identify and organize resources, especially by means of Selectors.

Each label key must be unique for a given object. Setting a different label value for the same key results in overwriting the value.

You can find more information about labels and selectors in the official [Kubernetes documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).

## Label policy for CES components

The label policy consists basically of two rules: 

1. for labeling a specific application as well as 
2. for labeling all moving parts after the machine was provisioned.

There are also two more reserved labels which are automatically produced by `k8s-dogu-operator`: 
- `dogu.name: <dogu-name>` and 
- `dogu.version: <dogu-version`

These labels **MUST NOT** be manually set because these labels are vital for the dogu upgrade procedure.

### 1. Labels that identify the application

**ALL** resources of a CES component **MUST** receive a label that enables the selection of the underlying application. This allows to identify all resources that entered this cluster by deploying this application.

The format of the label is: `app.kubernetes.io/name: <component-name>`

One example is to fully delete a component in order to replace it with another version which might bring less or different resources. Without a proper labeling that would leave unused resources which status of use might be unclear.

This syntax is taken from Helm application labels.

Example:

```yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  labels:
    app.kubernetes.io/name: your-ces-k8s-component-name
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/name: your-ces-k8s-component-name
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/name: your-ces-k8s-component-name
```

### 2. Labels that identify as removable part of the Cloudogu EcoSystem

**SOME** resources of a CES component **MUST** receive a label that groups all enables the selection of the underlying application. This allows to identify all resources that entered this cluster by official Cloudogu EcoSystem means.

The format of the label is: `app: ces`

The main example is to wipe an existing namespace from all CES components in order to execute a fresh setup **without** deleting the whole cluster or removing vital run-time information (like `setup.json`, instance credentials, or the Longhorn storage manager).

The label `app.kubernetes.io/name` stands in stark contrast to the label `app: ces` because the latter should not mark all resources in a CES cluster or even namespace. The motivation is simple: The label `app: ces` should enable the administrator with a way to _delete_ the necessary resources in order to re-start a fresh setup.

The following table should give you an idea, which resources should receive the `app: ces` label:

| Resource example                           | `app: ces`? | Reason                                                                                                      |
|--------------------------------------------|-------------|-------------------------------------------------------------------------------------------------------------|
| Instance credential secrets                | no          | It will be a pain to find the original instance credentials                                                 |
| Longhorn resources                         | no          | Longhorn is part of the infrastructure, deleting it will heavily impede a fresh setup                       |
| Customer added resources                   | no          | The `ces` label should never select resources that aren't our own.                                          |
| Original K3s cluster admin RBAC            | no          | Out-of-the-box resources count as resources that aren't our own.                                            |
| `k8s-dogu-operator` resources              | yes         | The operator should be able to be removed and reinstalled without any problems                              |
| Resources generated by `k8s-dogu-operator` | yes         | All resources that are generated by the CES during setup and regular run-time should receive the label      |
| Your new CES component 1                   | depends     | If the component is part of the infrastructure that should be installed during the cluster provisioning: No |
| Your new CES component 2                   | depends     | If the component is easy to reinstall or can be installed as part of the setup: Yes                         |

Example:

```yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  labels:
    app: ces
    app.kubernetes.io/name: your-other-k8s-component-name
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app: ces
    app.kubernetes.io/name: your-other-k8s-component-name
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: ces
    app.kubernetes.io/name: your-other-k8s-component-name
```

## How can labels help administrating the K8s-ecosystem?

This chapter describes some examples, so you can benefit of labels set by CES components. The underlying idea is to enumerate all Kubernetes API resources and pipe them to a `kubectl <action>` command for the given label and namespace.  

### Select all resource

Select all resources from the `ecosystem` namespace that are generated by the K8s ecosystem:

```bash
kubectl api-resources --verbs=list -o name | sort | xargs -t -n 1 \
  kubectl get --ignore-not-found \
    -l app=ces -n ecosystem
```

### Delete all CES resources

Delete all those resources from the `ecosystem` namespace 
- that are generated by the K8s ecosystem and 
- which do not provide critical infrastructure

A fresh setup run should be still possible after these two calls.

```bash
# delete dogus first because the dogu operator is supposed to manage those resources 
kubectl delete dogus -l app=ces -n ecosystem
```

```bash
# delete all other resources
kubectl patch cm tcp-services -p '{"metadata":{"finalizers":null}}' --type=merge -n ecosystem || true \
&& kubectl patch cm udp-services -p '{"metadata":{"finalizers":null}}' --type=merge -n ecosystem || true \
&& kubectl delete statefulsets,deploy,secrets,cm,svc,sa,rolebindings,roles,clusterrolebindings,clusterroles,cronjob,pvc,pv --ignore-not-found -l app=ces -n ecosystem
```

### Delete resources from one or more components

Installing a component oftentimes goes along with different resources types, like deployments, configmaps and more. Deleting a component with all its associated resources should be possible with a call like this.

This example deletes all resources from the component that identifies as `app.kubernetes.io/name=k8s-ces-setup` from the namespace `ecosystem`:

```bash
kubectl api-resources --verbs=list -o name | sort | xargs -t -n 1 \
  kubectl delete --ignore-not-found \
    -l app.kubernetes.io/name=k8s-ces-setup -n ecosystem
```

Multiple components can be selected with [set-based label requirements](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#set-based-requirement) (which work like a logical `OR`):

```bash
kubectl api-resources --verbs=list -o name | sort | xargs -t -n 1 \
  kubectl delete --ignore-not-found \
    -l 'app.kubernetes.io/name in (k8s-ces-setup, k8s-dogu-operator)' -n ecosystem
```

## Labels versus Annotations

Labels provide a way of adding a semantic identity to resources. Using CLI tools like `kubectl` can efficiently query resources with labels.  

Annotations on the other side provide non-identifying information. The target audience is rather clients like tools or libraries that oftentimes use this information to modify the way they are executed.

In general, labels can be used as much as you like while annotations should be used sparingly. Labels are the go-to mechanism when it comes to put a visible marker to resources which should be recognized by humans.
